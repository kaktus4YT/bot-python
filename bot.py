import discord
from discord.ext import commands, tasks
from discord.utils import get
import asyncio
import os
from discord import app_commands
import logging
import random
import datetime
from discord.ui import Button, View
import json
from datetime import datetime, timedelta
from mcrcon import MCRcon


intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

bot = commands.Bot(command_prefix="!", intents=intents)
tree = bot.tree

DATA_FILE = "data.json"

GUILD_ID = ""
RCON_HOST = "localhost"  # Adres serwera Minecraft
RCON_PORT = 25575        # Domy≈õlny port RCON
RCON_PASSWORD = ""  # Has≈Ço RCON

giveaways = {}
support_data = {}

LEVELS_FILE = "levels.json"

@bot.event
async def on_ready():
    await tree.sync()  # Synchronizuje slash komendy z Discordem
    print(f'Zalogowano jako {bot.user}')
    print(f'Bot zalogowany jako {bot.user}')
    guild = discord.utils.get(bot.guilds, id=int(GUILD_ID))
    print("Komendy zarejestrowane")

    guild = discord.Object(id=GUILD_ID)

    try:
        bot.tree.copy_global_to(guild=guild)
        await bot.tree.sync(guild=guild)
        print("Komendy zosta≈Çy zsynchronizowane.")
    except Exception as e:
        print(f"B≈ÇƒÖd synchronizacji komend: {e}")

# Klasa do obs≈Çugi przycisk√≥w
class TicketButton(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Otw√≥rz Ticket", style=discord.ButtonStyle.green)
    async def open_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        guild = interaction.guild
        if guild is None:
            await interaction.response.send_message("WystƒÖpi≈Ç problem. Nie mo≈ºna odnale≈∫ƒá serwera.", ephemeral=True)
            return

        await interaction.response.defer(ephemeral=True)
        
        existing_channel = get(guild.channels, name=f'ticket-{interaction.user.name.lower()}')
        if existing_channel:
            await interaction.followup.send(f'Masz ju≈º otwarty ticket: {existing_channel.mention}', ephemeral=True)
            return

        category = get(guild.categories, name="Tickety")
        
        if not category:
            category = await guild.create_category("Tickety")
        
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(view_channel=False),
            interaction.user: discord.PermissionOverwrite(view_channel=True, send_messages=True, read_message_history=True),
            guild.me: discord.PermissionOverwrite(view_channel=True, send_messages=True, read_message_history=True),
        }
        
        channel = await category.create_text_channel(f'ticket-{interaction.user.name}', overwrites=overwrites)
        await channel.send(
            f'{interaction.user.mention}, Twoje zg≈Çoszenie zosta≈Ço utworzone. Opisz sw√≥j problem, a kto≈õ z administracji Ci pomo≈ºe!',
            view=CloseTicketButton()
        )
        logger.info(f'U≈ºytkownik {interaction.user} otworzy≈Ç ticket: {channel.name}')  # Logowanie tworzenia ticketu
        await interaction.followup.send(f'Tw√≥j ticket zosta≈Ç utworzony: {channel.mention}', ephemeral=True)

class CloseTicketButton(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Zamknij Ticket", style=discord.ButtonStyle.red)
    async def close_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        channel = interaction.channel
        if "ticket-" in channel.name:
            await interaction.response.send_message(f'Ticket zostanie zamkniƒôty za 5 sekund...', ephemeral=True)
            await asyncio.sleep(5)

            transcript = f"Transkrypt kana≈Çu: {channel.name}\n\n"
            async for message in channel.history(limit=None):
                transcript += f"{message.created_at.strftime('%Y-%m-%d %H:%M:%S')} - {message.author.display_name}: {message.content}\n"
            transcript_filename = f"transcript_{channel.name}.txt"
            with open(transcript_filename, "w", encoding="utf-8") as file:
                file.write(transcript)

            admin_channel_id = 1278970391225958451  # ZastƒÖp to rzeczywistym ID kana≈Çu
            admin_channel = interaction.guild.get_channel(admin_channel_id)
            if admin_channel:
                await admin_channel.send(file=discord.File(transcript_filename))

            await interaction.user.send("Tw√≥j ticket zosta≈Ç zamkniƒôty. Oto transkrypt rozmowy:", file=discord.File(transcript_filename))
            os.remove(transcript_filename)
            
            logger.info(f'Ticket {channel.name} zosta≈Ç zamkniƒôty przez {interaction.user}')  # Logowanie zamkniƒôcia ticketu
            await channel.delete()
        else:
            await interaction.response.send_message("Nie mo≈ºesz zamknƒÖƒá tego kana≈Çu, poniewa≈º nie jest to ticket.", ephemeral=True)

# Komenda do wy≈õwietlania panelu z przyciskiem do otwierania ticketu na kanale, na kt√≥rym komenda zosta≈Ça u≈ºyta
@tree.command(name="panel", description="Wy≈õwietla panel do tworzenia ticket√≥w na bie≈ºƒÖcym kanale")
async def panel(interaction: discord.Interaction):
    channel = interaction.channel  # Pobiera kana≈Ç, na kt√≥rym zosta≈Ça u≈ºyta komenda

    embed = discord.Embed(
        title="Pomoc",
        description="Kliknij przycisk poni≈ºej, aby otworzyƒá ticket.",
        color=discord.Color.green()
    )
    view = TicketButton()
    await channel.send(embed=embed, view=view)
    await interaction.response.send_message(f'Panel do tworzenia ticket√≥w zosta≈Ç wys≈Çany na {channel.mention}.', ephemeral=True)

@tree.command(name="close", description="Zamyka ticket i tworzy transkrypt")
async def close(interaction: discord.Interaction):
    channel = interaction.channel
    if "ticket-" in channel.name:
        transcript = f"Transkrypt kana≈Çu: {channel.name}\n\n"
        
        async for message in channel.history(limit=None):
            transcript += f"{message.created_at.strftime('%Y-%m-%d %H:%M:%S')} - {message.author.display_name}: {message.content}\n"
        
        transcript_filename = f"transcript_{channel.name}.txt"
        with open(transcript_filename, "w", encoding="utf-8") as file:
            file.write(transcript)
        
        admin_channel_id = 1278970391225958451  # ZastƒÖp to rzeczywistym ID kana≈Çu
        admin_channel = interaction.guild.get_channel(admin_channel_id)
        if admin_channel:
            await admin_channel.send(file=discord.File(transcript_filename))

        await interaction.user.send("Tw√≥j ticket zosta≈Ç zamkniƒôty. Oto transkrypt rozmowy:", file=discord.File(transcript_filename))
        os.remove(transcript_filename)
        
        await interaction.response.send_message(f'Ten ticket zostanie zamkniƒôty za 5 sekund...', ephemeral=True)
        await asyncio.sleep(5)
        await channel.delete()
    else:
        await interaction.response.send_message("Nie mo≈ºesz zamknƒÖƒá tego kana≈Çu, poniewa≈º nie jest to ticket.", ephemeral=True)

@tree.command(name="adduser", description="Dodaje u≈ºytkownika do ticketu")
@app_commands.describe(member="Cz≈Çonek do dodania")
async def adduser(interaction: discord.Interaction, member: discord.Member):
    channel = interaction.channel
    if "ticket-" in channel.name:
        await channel.set_permissions(member, view_channel=True, send_messages=True, read_message_history=True)
        await interaction.response.send_message(f'{member.mention} zosta≈Ç dodany do ticketu.', ephemeral=True)
    else:
        await interaction.response.send_message("Ta komenda mo≈ºe byƒá u≈ºywana tylko w kana≈Çach ticketu.", ephemeral=True)

@tree.command(name="removeuser", description="Usuwa u≈ºytkownika z ticketu")
@app_commands.describe(member="Cz≈Çonek do usuniƒôcia")
async def removeuser(interaction: discord.Interaction, member: discord.Member):
    channel = interaction.channel
    if "ticket-" in channel.name:
        await channel.set_permissions(member, overwrite=None)
        await interaction.response.send_message(f'{member.mention} zosta≈Ç usuniƒôty z ticketu.', ephemeral=True)
    else:
        await interaction.response.send_message("Ta komenda mo≈ºe byƒá u≈ºywana tylko w kana≈Çach ticketu.", ephemeral=True)

@tree.command(name="rename", description="Zmienia nazwƒô kana≈Çu ticketu")
@app_commands.describe(new_name="Nowa nazwa kana≈Çu")
async def rename(interaction: discord.Interaction, new_name: str):
    channel = interaction.channel
    if "ticket-" in channel.name:
        old_name = channel.name
        await channel.edit(name=new_name)
        await interaction.response.send_message(f'Nazwa kana≈Çu zosta≈Ça zmieniona z `{old_name}` na `{new_name}`.', ephemeral=True)
    else:
        await interaction.response.send_message("Ta komenda mo≈ºe byƒá u≈ºywana tylko w kana≈Çach ticketu.", ephemeral=True)

# Function to end a giveaway based on prize name
async def end_giveaway(prize):
    giveaway = giveaways.get(prize)
    if giveaway and giveaway["active"]:
        channel = giveaway["channel"]
        message = await channel.fetch_message(giveaway["message_id"])
        users = []
        
        async for user in message.reactions[0].users():
            if user != bot.user:
                users.append(user)
        
        if len(users) == 0:
            await channel.send(f'Nikt nie wziƒÖ≈Ç udzia≈Çu w giveaway na **{prize}**.')
        else:
            winner = random.choice(users)
            await channel.send(f'üéâ Gratulacje, {winner.mention}! Wygra≈Çe≈õ **{prize}**!')
            await winner.send(f'Gratulacje! Wygra≈Çe≈õ **{prize}** w giveaway na serwerze {channel.guild.name}!')
            logger.info(f'Giveaway zako≈Ñczony. Nagroda: {prize}, Zwyciƒôzca: {winner}')
            
            # Debug print to check role assignment
            print(f"Looking for role: {prize}")
            
            # Assign the role if the prize is a role
            role = discord.utils.get(channel.guild.roles, name=prize)
            if role:
                print(f"Role found: {role.name}")
                await winner.add_roles(role)
                await channel.send(f'{winner.mention} otrzyma≈Ç rolƒô **{prize}** jako nagrodƒô!')
                await winner.send(f'Otrzyma≈Çe≈õ rolƒô **{prize}** na serwerze {channel.guild.name} jako nagrodƒô!')
            else:
                print(f"Role not found: {prize}")

        giveaways[prize]["active"] = False
    else:
        logger.warning(f"Pr√≥ba zako≈Ñczenia giveaway, kt√≥ry nie istnieje lub zosta≈Ç ju≈º zako≈Ñczony.")

# Command to start a giveaway
@tree.command(name="giveaway", description="Rozpoczyna giveaway")
@app_commands.describe(prize="Nagroda w giveaway", duration="Czas trwania (np. 10m, 1h)")
async def giveaway(interaction: discord.Interaction, prize: str, duration: str):
    time_multiplier = {"m": 60, "h": 3600, "d": 86400}
    unit = duration[-1]

    if unit not in time_multiplier:
        await interaction.response.send_message("Podaj poprawny czas trwania, np. 10m, 1h, 1d.", ephemeral=True)
        return

    try:
        duration_seconds = int(duration[:-1]) * time_multiplier[unit]
    except ValueError:
        await interaction.response.send_message("Podaj poprawny czas trwania, np. 10m, 1h, 1d.", ephemeral=True)
        return

    end_time = datetime.datetime.now(datetime.UTC) + datetime.timedelta(seconds=duration_seconds)
    giveaway_embed = discord.Embed(
        title="üéâ Giveaway! üéâ",
        description=f"Wygraj **{prize}**!\nReaguj üéâ, aby wziƒÖƒá udzia≈Ç!",
        color=discord.Color.blue(),
        timestamp=end_time
    )
    giveaway_embed.set_footer(text="Zako≈Ñczenie")

    message = await interaction.channel.send(embed=giveaway_embed)
    await message.add_reaction("üéâ")
    await interaction.response.send_message(f'Giveaway o nagrodƒô **{prize}** zosta≈Ç rozpoczƒôty!', ephemeral=True)

    # Store giveaway data, using prize as the key
    giveaways[prize] = {
        "channel": interaction.channel,
        "prize": prize,
        "end_time": end_time,
        "message_id": message.id,
        "active": True
    }

    await asyncio.sleep(duration_seconds)

    # End the giveaway if it hasn't been ended early
    if giveaways[prize]["active"]:
        await end_giveaway(prize)

# Command to end a giveaway based on prize name
@tree.command(name="end_giveaway", description="Przedwcze≈õnie ko≈Ñczy giveaway")
@app_commands.describe(prize="Nazwa nagrody w giveaway")
async def end_giveaway_command(interaction: discord.Interaction, prize: str):
    if prize in giveaways and giveaways[prize]["active"]:
        await end_giveaway(prize)
        await interaction.response.send_message(f'Giveaway na **{prize}** zosta≈Ç zako≈Ñczony przedwcze≈õnie.', ephemeral=True)
    else:
        await interaction.response.send_message(f'Nie znaleziono aktywnego giveaway z nagrodƒÖ **{prize}**.', ephemeral=True)

# Error handling for app commands
@tree.error
async def on_tree_error(interaction: discord.Interaction, error: discord.app_commands.AppCommandError):
    if interaction.response.is_done():
        await interaction.followup.send("WystƒÖpi≈Ç b≈ÇƒÖd przy wykonywaniu komendy.", ephemeral=True)
    else:
        await interaction.response.send_message("WystƒÖpi≈Ç b≈ÇƒÖd przy wykonywaniu komendy.", ephemeral=True)
    logger.error(f'WystƒÖpi≈Ç b≈ÇƒÖd w komendzie: {error}')


# Komenda do banowania u≈ºytkownika
@tree.command(name="ban", description="Banuje u≈ºytkownika")
@app_commands.describe(member="U≈ºytkownik do zbanowania", reason="Pow√≥d zbanowania")
async def ban(interaction: discord.Interaction, member: discord.Member, reason: str = None):
    await member.send(f"Zosta≈Çe≈õ zbanowany na serwerze {interaction.guild.name} za: {reason}")
    await member.ban(reason=reason)
    await interaction.channel.send(f'{member.mention} zosta≈Ç zbanowany za: {reason}.')
    await interaction.response.send_message(f'{member.mention} zosta≈Ç zbanowany za: {reason}', ephemeral=True)

# Komenda do odbanowania u≈ºytkownika
@tree.command(name="unban", description="Odbanowuje u≈ºytkownika")
@app_commands.describe(member="U≈ºytkownik do odbanowania (format: nazwa#1234)")
async def unban(interaction: discord.Interaction, member: str):
    banned_users = await interaction.guild.bans()
    member_name, member_discriminator = member.split('#')

    for ban_entry in banned_users:
        user = ban_entry.user

        if (user.name, user.discriminator) == (member_name, member_discriminator):
            await interaction.guild.unban(user)
            await interaction.channel.send(f'{user.mention} zosta≈Ç odbanowany.')
            await user.send(f"Zosta≈Çe≈õ odbanowany na serwerze {interaction.guild.name}.")
            await interaction.response.send_message(f'{user.mention} zosta≈Ç odbanowany.', ephemeral=True)
            return

    await interaction.response.send_message(f'U≈ºytkownik {member} nie zosta≈Ç znaleziony w li≈õcie zbanowanych.', ephemeral=True)

# Modal do zbierania opinii lub zg≈Çosze≈Ñ od u≈ºytkownik√≥w z dwoma pytaniami
class FeedbackModal(discord.ui.Modal, title="Zg≈Çoszenie"):
    question1 = discord.ui.TextInput(
        label="Nick Minecraft",
        style=discord.TextStyle.short,
        placeholder="",
        required=True,
        max_length=100
    )

    question2 = discord.ui.TextInput(
        label="Wiek",
        style=discord.TextStyle.short,
        placeholder="",
        required=True,
        max_length=100
    )

    question3 = discord.ui.TextInput(
        label="Do≈õwiadczenie",
        style=discord.TextStyle.long,
        placeholder="",
        required=True,
        max_length=500
    )

    async def on_submit(self, interaction: discord.Interaction):
        # Wy≈õlij tre≈õƒá modalu na okre≈õlony kana≈Ç
        admin_channel_id = 1269255707296010342  # ZastƒÖp to rzeczywistym ID kana≈Çu
        admin_channel = interaction.guild.get_channel(admin_channel_id)
        if admin_channel:
            embed = discord.Embed(
                title="Nowe zg≈Çoszenie",
                color=discord.Color.green()
            )
            embed.add_field(name="Nick Minecraft", value=self.question1.value, inline=False)
            embed.add_field(name="Wiek", value=self.question2.value or "Brak odpowiedzi", inline=False)
            embed.add_field(name="Do≈õwiadczenie", value=self.question3.value or "Brak odpowiedzi", inline=False)
            embed.add_field(name="U≈ºytkownik", value=interaction.user.mention, inline=False)
            await admin_channel.send(embed=embed)
            await interaction.response.send_message("Dziƒôkujemy za Twoje zg≈Çoszenie!", ephemeral=True)
        else:
            await interaction.response.send_message("WystƒÖpi≈Ç problem przy wysy≈Çaniu opinii.", ephemeral=True)

@tree.command(name="zg≈Çoszenie", description="Otwiera formularz do przes≈Çania zg≈Çoszenia")
async def feedback(interaction: discord.Interaction):
    # Wy≈õwietlenie modalu
    modal = FeedbackModal()
    await interaction.response.send_modal(modal)

# Komenda do wysy≈Çania propozycji do administracji
@tree.command(name="propozycja", description="Wysy≈Ça propozycjƒô do administracji")
@app_commands.describe(content="Tre≈õƒá propozycji")
async def propozycja(interaction: discord.Interaction, content: str):
    admin_channel_id = 1277889128565968958  # ZastƒÖp to rzeczywistym ID kana≈Çu

    admin_channel = bot.get_channel(admin_channel_id)
    if admin_channel:
        embed = discord.Embed(
            title="Nowa propozycja",
            description=content,
            color=discord.Color.green()
        )
        embed.add_field(name="U≈ºytkownik", value=interaction.user.mention, inline=False)
        embed.set_footer(text=f"ID propozycji: {interaction.id}")

        await admin_channel.send(embed=embed)
        await interaction.response.send_message(f'Twoja propozycja zosta≈Ça wys≈Çana do administracji!', ephemeral=True)
    else:
        await interaction.response.send_message('Nie uda≈Ço siƒô znale≈∫ƒá kana≈Çu administracyjnego. Sprawd≈∫ konfiguracjƒô.', ephemeral=True)

@tree.command(name="propozycja_akceptuj", description="Akceptuje propozycjƒô u≈ºytkownika")
@app_commands.describe(proposal_id="ID wiadomo≈õci z propozycjƒÖ")
async def propozycja_akceptuj(interaction: discord.Interaction, proposal_id: int):
    try:
        # Pr√≥ba pobrania wiadomo≈õci na podstawie ID
        proposal_message = await interaction.channel.fetch_message(proposal_id)
    except discord.NotFound:
        # Wiadomo≈õƒá nie zosta≈Ça znaleziona
        await interaction.response.send_message(f'Nie znaleziono wiadomo≈õci o ID {proposal_id}.', ephemeral=True)
        return
    except discord.Forbidden:
        # Brak dostƒôpu do kana≈Çu/wiadomo≈õci
        await interaction.response.send_message('Nie mam uprawnie≈Ñ do pobrania tej wiadomo≈õci.', ephemeral=True)
        return
    except discord.HTTPException:
        # Og√≥lny b≈ÇƒÖd HTTP
        await interaction.response.send_message('WystƒÖpi≈Ç b≈ÇƒÖd przy pobieraniu wiadomo≈õci.', ephemeral=True)
        return

    # Je≈õli wiadomo≈õƒá zosta≈Ça pomy≈õlnie pobrana, kontynuujemy proces
    user_mention = proposal_message.embeds[0].fields[0].value
    user = await commands.MemberConverter().convert(interaction, user_mention)
    
    if user:
        await user.send(f'Twoja propozycja (ID: {proposal_id}) zosta≈Ça zaakceptowana!')
        await interaction.response.send_message(f'Propozycja {proposal_id} zosta≈Ça zaakceptowana.', ephemeral=True)
    else:
        await interaction.response.send_message('Nie uda≈Ço siƒô wys≈Çaƒá wiadomo≈õci prywatnej do u≈ºytkownika.', ephemeral=True)


@tree.command(name="propozycja_odrzuc", description="Odrzuca propozycjƒô u≈ºytkownika")
@app_commands.describe(proposal_id="ID wiadomo≈õci z propozycjƒÖ")
async def propozycja_odrzuc(interaction: discord.Interaction, proposal_id: int):
    proposal_message = await interaction.channel.fetch_message(proposal_id)
    if proposal_message:
        user_mention = proposal_message.embeds[0].fields[0].value
        user = await commands.MemberConverter().convert(interaction, user_mention)
        if user:
            await user.send(f'Twoja propozycja (ID: {proposal_id}) zosta≈Ça odrzucona.')
            await interaction.response.send_message(f'Propozycja {proposal_id} zosta≈Ça odrzucona.', ephemeral=True)
        else:
            await interaction.response.send_message('Nie uda≈Ço siƒô wys≈Çaƒá wiadomo≈õci prywatnej do u≈ºytkownika.', ephemeral=True)
    else:
        await interaction.response.send_message('Nie znaleziono wiadomo≈õci z tƒÖ propozycjƒÖ.', ephemeral=True)

# Konfiguracja systemu log√≥w
logging.basicConfig(
    level=logging.INFO,  # Mo≈ºesz ustawiƒá poziom logowania na DEBUG, INFO, WARNING, ERROR, CRITICAL
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('discord_bot.log'),  # Logi bƒôdƒÖ zapisywane do pliku 'discord_bot.log'
        logging.StreamHandler()  # Logi bƒôdƒÖ r√≥wnie≈º wy≈õwietlane w konsoli
    ]
)

logger = logging.getLogger(__name__)

@bot.event
async def on_command_error(ctx, error):
    logger.error(f'WystƒÖpi≈Ç b≈ÇƒÖd: {str(error)}')
    await ctx.send(f'WystƒÖpi≈Ç b≈ÇƒÖd: {str(error)}')

@bot.command()
@commands.has_permissions(manage_roles=True)
async def awans(ctx, member: discord.Member, role: discord.Role):
    try:
        await member.add_roles(role)
        await ctx.send(f'Awansowano {member.mention} na rolƒô {role.name}.')
    except discord.Forbidden:
        await ctx.send('Nie mam uprawnie≈Ñ do zarzƒÖdzania rolami.')
    except discord.HTTPException as e:
        await ctx.send(f'WystƒÖpi≈Ç b≈ÇƒÖd: {e}')

@bot.command()
@commands.has_permissions(administrator=True)
async def degrad(ctx, member: discord.Member, role: discord.Role):
    try:
        await member.remove_roles(role)
        await ctx.send(f'Zdegradowano {member.mention} z roli {role.name}.')
    except discord.Forbidden:
        await ctx.send('Nie mam uprawnie≈Ñ do zarzƒÖdzania rolami.')
    except discord.HTTPException as e:
        await ctx.send(f'WystƒÖpi≈Ç b≈ÇƒÖd: {e}')

# Kana≈Ç do log√≥w
LOG_CHANNEL_ID = 1275890698737942598  # Podaj ID kana≈Çu, na kt√≥rym chcesz wysy≈Çaƒá logi

# Logowanie do≈ÇƒÖczenia u≈ºytkownika
@bot.event
async def on_member_join(member):
    log_channel = bot.get_channel(LOG_CHANNEL_ID)
    await log_channel.send(f'{member} do≈ÇƒÖczy≈Ç do serwera.')

# Logowanie opuszczenia u≈ºytkownika
@bot.event
async def on_member_remove(member):
    log_channel = bot.get_channel(LOG_CHANNEL_ID)
    await log_channel.send(f'{member} opu≈õci≈Ç serwer.')

# Logowanie usuniƒôcia wiadomo≈õci
@bot.event
async def on_message_delete(message):
    log_channel = bot.get_channel(LOG_CHANNEL_ID)
    await log_channel.send(f'Wiadomo≈õƒá od {message.author} zosta≈Ça usuniƒôta z kana≈Çu {message.channel}: {message.content}')

# Logowanie edycji wiadomo≈õci
@bot.event
async def on_message_edit(before, after):
    log_channel = bot.get_channel(LOG_CHANNEL_ID)
    await log_channel.send(f'Wiadomo≈õƒá od {before.author} na kanale {before.channel} zosta≈Ça edytowana z "{before.content}" na "{after.content}"')

# Logowanie dodawania roli u≈ºytkownikowi
@bot.event
async def on_member_update(before, after):
    log_channel = bot.get_channel(LOG_CHANNEL_ID)
    
    # Sprawdzenie dodanych r√≥l
    added_roles = [role for role in after.roles if role not in before.roles]
    removed_roles = [role for role in before.roles if role not in after.roles]

    if added_roles:
        await log_channel.send(f'{after} otrzyma≈Ç rolƒô: {", ".join(role.name for role in added_roles)}')
    if removed_roles:
        await log_channel.send(f'{after} straci≈Ç rolƒô: {", ".join(role.name for role in removed_roles)}')

@bot.command()
async def weryfikacja(ctx):
    # Tworzenie embeda
    embed = discord.Embed(title="Weryfikacja", description="Kliknij przycisk poni≈ºej, aby zweryfikowaƒá i uzyskaƒá rolƒô.", color=discord.Color.green())

    # Tworzenie przycisku
    button = Button(label="Zweryfikuj siƒô", style=discord.ButtonStyle.success)

    async def button_callback(interaction):
        role = discord.utils.get(interaction.guild.roles, name="üì∫„ÉªGracz")  # Zmie≈Ñ "Zweryfikowany" na nazwƒô roli, kt√≥rƒÖ chcesz nadaƒá
        if role:
            if role not in interaction.user.roles:
                await interaction.user.add_roles(role)
                await interaction.response.send_message("Pomy≈õlnie zweryfikowano! Otrzyma≈Çe≈õ rolƒô.", ephemeral=True)
            else:
                await interaction.response.send_message("Ju≈º posiadasz tƒô rolƒô.", ephemeral=True)
        else:
            await interaction.response.send_message("Rola nie zosta≈Ça znaleziona.", ephemeral=True)

    button.callback = button_callback

    # Tworzenie widoku i dodawanie przycisku
    view = View()
    view.add_item(button)

    # Wysy≈Çanie wiadomo≈õci z embedem i przyciskiem
    await ctx.send(embed=embed, view=view)

# Funkcja do ≈Çadowania danych z pliku JSON
def load_levels():
    if os.path.exists(LEVELS_FILE):
        with open(LEVELS_FILE, "r") as file:
            return json.load(file)
    return {}

# Funkcja do zapisywania danych do pliku JSON
def save_levels(levels):
    with open(LEVELS_FILE, "w") as file:
        json.dump(levels, file, indent=4)

# Funkcja do obliczania potrzebnego XP na dany poziom
def xp_for_next_level(level):
    return 5 * (level ** 2) + 50 * level + 100

# Event, kt√≥ry uruchamia siƒô przy ka≈ºdej wiadomo≈õci
@bot.event
async def on_message(message):
    if message.author.bot:
        return

    levels = load_levels()

    user_id = str(message.author.id)
    if user_id not in levels:
        levels[user_id] = {"xp": 0, "level": 1}

    levels[user_id]["xp"] += 10  # Przyznaj 10 XP za ka≈ºdƒÖ wiadomo≈õƒá

    current_xp = levels[user_id]["xp"]
    current_level = levels[user_id]["level"]
    next_level_xp = xp_for_next_level(current_level)

    if current_xp >= next_level_xp:
        levels[user_id]["level"] += 1
        levels[user_id]["xp"] = current_xp - next_level_xp
        await message.channel.send(f"Gratulacje, {message.author.mention}! OsiƒÖgnƒÖ≈Çe≈õ poziom {levels[user_id]['level']}!")

    save_levels(levels)

    await bot.process_commands(message)

# Komenda do sprawdzania poziomu u≈ºytkownika
@bot.command(name="poziom")
async def level(ctx, member: discord.Member = None):
    if member is None:
        member = ctx.author

    levels = load_levels()
    user_id = str(member.id)

    if user_id in levels:
        await ctx.send(f"{member.mention} jest na poziomie {levels[user_id]['level']} z {levels[user_id]['xp']} XP.")
    else:
        await ctx.send(f"{member.mention} nie zdoby≈Ç jeszcze ≈ºadnego XP.")


# Funkcja do zapisywania danych do pliku
def save_data(data):
    with open(DATA_FILE, "w") as f:
        json.dump(data, f, indent=4)

def load_data():
    try:
        with open(DATA_FILE, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        # Tworzymy pustƒÖ strukturƒô, je≈õli plik nie istnieje
        save_data({})
        return {}
    except json.JSONDecodeError:
        # Obs≈Çuga b≈Çƒôdu, je≈õli plik jest uszkodzony lub pusty
        print("B≈ÇƒÖd: Plik JSON jest uszkodzony. Tworzenie nowego pliku.")
        save_data({})
        return {}        

# Funkcja do rejestrowania mut√≥w i warn√≥w
def log_action(user_id, action, reason=None, duration=None):
    data = load_data()
    if str(user_id) not in data:
        data[str(user_id)] = {"mutes": [], "warns": []}

    if action == "mute":
        mute_info = {
            "timestamp": str(datetime.utcnow()),
            "reason": reason,
            "duration": duration  # Czas trwania w minutach
        }
        data[str(user_id)]["mutes"].append(mute_info)
    elif action == "warn":
        warn_info = {
            "timestamp": str(datetime.utcnow()),
            "reason": reason
        }
        data[str(user_id)]["warns"].append(warn_info)

    save_data(data)

# Funkcja do tworzenia roli muta, je≈õli jej nie ma
async def create_mute_role(guild):
    mute_role = discord.utils.get(guild.roles, name="Muted")
    if mute_role is None:
        permissions = discord.Permissions(send_messages=False, speak=False)
        mute_role = await guild.create_role(name="Muted", permissions=permissions)
        
        # Ustawienia kana≈Ç√≥w, aby uniemo≈ºliwiƒá wysy≈Çanie wiadomo≈õci
        for channel in guild.channels:
            await channel.set_permissions(mute_role, send_messages=False, speak=False)
    
    return mute_role

# Funkcja do sprawdzania, czy mute wygas≈Ç
def is_mute_expired(mute):
    mute_time = datetime.fromisoformat(mute["timestamp"])
    duration = timedelta(minutes=mute["duration"])
    return datetime.utcnow() > mute_time + duration

# Task automatycznie sprawdzajƒÖcy wygas≈Çe muty
@tasks.loop(minutes=1)
async def check_mutes():
    print("Rozpoczƒôcie zadania sprawdzania mut√≥w...")
    try:
        data = load_data()
        for guild in bot.guilds:
            print(f"Sprawdzanie serwera: {guild.name}")
            mute_role = await create_mute_role(guild)
            for user_id, user_data in data.items():
                member = guild.get_member(int(user_id))
                if member is None:
                    continue

                # Sprawdzenie aktywnych mut√≥w
                active_mutes = []
                for mute in user_data["mutes"]:
                    if not is_mute_expired(mute):
                        active_mutes.append(mute)
                    else:
                        # Je≈õli mute wygas≈Ç, zdejmujemy rolƒô "Muted"
                        if mute_role in member.roles:
                            await member.remove_roles(mute_role)
                            await member.send(f"Tw√≥j mute na serwerze {guild.name} wygas≈Ç.")
                user_data["mutes"] = active_mutes
        save_data(data)
    except Exception as e:
        print(f"B≈ÇƒÖd w zadaniu check_mutes: {e}")

# Komenda do na≈Ço≈ºenia muta
@bot.command()
async def mute(ctx, member: discord.Member, duration: int, *, reason=None):
    # Rejestrujemy muta
    log_action(member.id, "mute", reason, duration)
    
    # Tworzymy lub uzyskujemy rolƒô "Muted"
    mute_role = await create_mute_role(ctx.guild)
    
    # Nadajemy rolƒô wyciszenia
    await member.add_roles(mute_role)
    
    await ctx.send(f"{member.name} zosta≈Ç wyciszony na {duration} minut. Pow√≥d: {reason or 'Brak powodu'}")

# Komenda do usuniƒôcia muta (unmute)
@bot.command()
async def unmute(ctx, member: discord.Member):
    data = load_data()
    
    if str(member.id) not in data or not data[str(member.id)]["mutes"]:
        await ctx.send(f"{member.name} nie ma aktywnych mut√≥w.")
        return
    
    # Usuwamy ostatni mute
    last_mute = data[str(member.id)]["mutes"].pop()
    save_data(data)
    
    # Usuwamy rolƒô "Muted"
    mute_role = discord.utils.get(ctx.guild.roles, name="Muted")
    if mute_role in member.roles:
        await member.remove_roles(mute_role)
    
    await ctx.send(f"Ostatni mute dla {member.name} z dnia {last_mute['timestamp']} zosta≈Ç usuniƒôty.")

# Komenda do sprawdzenia liczby mut√≥w i warn√≥w
@bot.command()
async def stats(ctx, member: discord.Member = None):
    member = member or ctx.author  # Je≈õli nie podano u≈ºytkownika, sprawdzamy dane osoby wysy≈ÇajƒÖcej komendƒô
    data = load_data()
    
    if str(member.id) not in data:
        await ctx.send(f"Brak danych dla {member.name}.")
        return
    
    mutes = data[str(member.id)]["mutes"]
    warns = data[str(member.id)]["warns"]
    
    # Liczba mut√≥w i warn√≥w w okre≈õlonych okresach czasowych
    mutes_week = count_recent_actions(mutes, 7)
    warns_week = count_recent_actions(warns, 7)
    mutes_month = count_recent_actions(mutes, 30)
    warns_month = count_recent_actions(warns, 30)
    mutes_all_time = len(mutes)
    warns_all_time = len(warns)
    
    # Wy≈õwietlamy muty z powodami i czasem trwania
    mute_details = "\n".join([f"- Mute z dnia {mute['timestamp']} na {mute['duration']} minut, pow√≥d: {mute['reason'] or 'Brak powodu'}"
                              for mute in mutes])
    
    warn_details = "\n".join([f"- Warn z dnia {warn['timestamp']}, pow√≥d: {warn['reason'] or 'Brak powodu'}"
                              for warn in warns])
    
    await ctx.send(f"Statystyki dla {member.name}:\n"
                   f"- Mute w tym tygodniu: {mutes_week}\n"
                   f"- Warn w tym tygodniu: {warns_week}\n"
                   f"- Mute w tym miesiƒÖcu: {mutes_month}\n"
                   f"- Warn w tym miesiƒÖcu: {warns_month}\n"
                   f"- Mute og√≥lnie: {mutes_all_time}\n"
                   f"- Warn og√≥lnie: {warns_all_time}\n\n"
                   f"**Szczeg√≥≈Çy mut√≥w:**\n{mute_details or 'Brak mut√≥w'}\n\n"
                   f"**Szczeg√≥≈Çy warn√≥w:**\n{warn_details or 'Brak warn√≥w'}")

# Task do sprawdzania wygas≈Çych mut√≥w
@bot.event
async def on_ready():
    check_mutes.start()  # Uruchamiamy task
    print(f'Zalogowano jako {bot.user}!')

def count_recent_actions(action_list, days):
    now = datetime.utcnow()
    count = 0
    for action in action_list:
        action_time = datetime.fromisoformat(action["timestamp"])
        if now - action_time <= timedelta(days=days):
            count += 1
    return count   

# Komenda /pluginy
@tree.command(name="pluginy", description="Wy≈õwietla listƒô plugin√≥w Minecraft")
async def pluginy(interaction: discord.Interaction):
    try:
        # Po≈ÇƒÖczenie z RCON i pobranie listy plugin√≥w
        with MCRcon(RCON_HOST, RCON_PASSWORD, RCON_PORT) as mcr:
            response = mcr.command("plugins")
        
        # Odpowied≈∫ zawierajƒÖca listƒô plugin√≥w
        await interaction.response.send_message(f"Zainstalowane pluginy: {response}")
    
    except Exception as e:
        await interaction.response.send_message(f"WystƒÖpi≈Ç b≈ÇƒÖd podczas ≈ÇƒÖczenia z serwerem Minecraft: {e}")

# Komenda /ban
@tree.command(name="ban-mc", description="Banuje gracza na okre≈õlony czas")
@app_commands.describe(gracz="Nazwa gracza do zbanowania", czas="Czas bana w minutach")
async def ban(interaction: discord.Interaction, gracz: str, czas: int):
    try:
        # Po≈ÇƒÖczenie z RCON i banowanie gracza
        with MCRcon(RCON_HOST, RCON_PASSWORD, RCON_PORT) as mcr:
            ban_command = f"ban {gracz} {czas}m"
            response = mcr.command(ban_command)
        
        # Odpowied≈∫ na Discordzie o banie
        await interaction.response.send_message(f"Gracz {gracz} zosta≈Ç zbanowany na {czas} minut. Komunikat serwera: {response}")
        
        # Odbanowanie po czasie
        await asyncio.sleep(czas * 60)  # czas w minutach na sekundy
        with MCRcon(RCON_HOST, RCON_PASSWORD, RCON_PORT) as mcr:
            pardon_command = f"pardon {gracz}"
            mcr.command(pardon_command)
        
        # Informacja o odbanowaniu
        await interaction.followup.send(f"Gracz {gracz} zosta≈Ç odbanowany po {czas} minutach.")
    
    except Exception as e:
        await interaction.response.send_message(f"WystƒÖpi≈Ç b≈ÇƒÖd podczas banowania gracza: {e}")  

bot.run('')
